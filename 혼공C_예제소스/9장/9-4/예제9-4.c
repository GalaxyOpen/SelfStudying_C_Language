#include <stdio.h>

int main(void)
{
	int a = 10, b = 20;
	const int* pa = &a;                // 포인터 pa는 변수 a를 가리킨다.

	printf("변수 a 값 : %d\n", *pa);   // 포인터를 간접 참조하여 a 출력 : 변수 a 값 : 10
	pa = &b;                           // 포인터가 변수 b를 가리키게 한다.
	printf("변수 b 값 : %d\n", *pa);   // 포인터를 간접 참조하여 b 값 출력 : 변수 b 값 : 20
	pa = &a;                           // 포인터가 다시 변수 a를 가리킨다.
	a = 20;                            // a를 직접 참조하여 값을 바꾼다.
	printf("변수 a 값 : %d\n", *pa);   // 포인터로 간접 참조하여 바뀐 값 출력 : 변수 c 값 : 20

	return 0;
}

// const를 사용한 포인터 
// 예약어인 const를 포인터에 사용하면 가리키는 변수의 값을 바꿀 수 없음. 변수에 사용하는 것과 다른 의미를 가짐. 

// 위의 6행에서 포인터 pa를 선언할 때 const를 사용하여 상수화 함. 
// 만약 const가 일반 변수처럼 포인터 값을 고정시킨다면 9행에서 pa는 다른 변수의 주소를 저장할 수 없음. 
// 출력 결과에서 pa는 const 사용과 무관하게 변수 b의 주소를 저장하고 그 값을 간접 참조하여 출력하고 있음. 
// 여기서 포인터에 사용된 const의 의미를 생각해보면
// pa가 가리키는 변수 a는 pa를 간접 참조하여 바꿀 수 없다는 것. 12행에서 *pa=20; 과 같이 pa를 통해 a값을 바꿀 때 다음과 같은 에러가 발생함. 

// error C2166 : l-value가 const 개체를 지정합니다. 

// 그럼 const를 왜 사용할까? 
// 대표적으로 문자열 상수를 인수로 함수의 받을 경우가 된다. 문자열 상수는 값이 바뀌면 안되는 저장 공간이므로 함수의 매개변수를 통해서 값을 바꿀 수 없도록 
// 매개 변수로 선언된 포인터에 const를 사용함. 
