#include <stdio.h>

int main(void)
{
	int a;        // 일반 변수 선언
	int* pa;      // 포인터 선언

	pa = &a;      // 포인터에 a의 주소 대입
	*pa = 10;     // 포인터로 변수 a에 10 대입

	printf("포인터로 a 값 출력 : %d\n", *pa);	// 포인터로 a 값 출력 : 10
	printf("변수명으로 a 값 출력 : %d\n", a);    // 변수명으로 a 값 출력 : 10

	return 0;
}

// 포인터와 간접 참조 연산자 : *
// 위 코드는 변수에 할당된 메모리 주소를 활용하는 방법
// 메모리의 주소는 필요할 때마다 계속 주소 연산을 수행하는 것보다 한 번 구한 주소를 저장해서 사용하면 편리함.
// 포인터가 바로 변수의 메모리 주소를 저장하는 변수. 따라서 주소를 저장할 포인터도 변수처럼 선언하고 사용함. 
// 다만 선언할 때는 변수 앞에 *만 붙여주면 됨. 

// 6행이 포인터를 선언하는 부분. 규칙에 따라서 포인터 이름을 짓고 변수 명 앞에 *를 붙임. 
// *는 포인터임을 표시하는 기호. 그리고 자료형을 적는데, 포인터의 자료형은 변수의 자료형을 적음. 

// int *pa; 
// 포인터 변수가 선언되면 일반 변수와 마찬가지로 메모리에 저장 공간이 할당되고 그 이후엥는 변수 명으로 사용할 수 있음. 

// pa = &a; 
// 포인터에 a의 시작주소를 저장하는 문장. 예를 들어 변수 a가 메모리 100번지로부터 103번지까지 할당되면 주소 값 100이 pa에 저장됨. 
// 그리고 포인터 pa는 변수 a가 메모리 어디에 할당되었는지 그 위치를 기억하고 있음. 이렇게 포인터가 변수의 주소를 저장한 경우 '가리킨다' 라고 표현. 
// pa -> a 처럼 화살표로 간단히 표현하기도 함. 
// ex) x -> y 로 표현한다면 'x는 y를 가리킨다' 라고 말할 수 있음. 여기서 x는 포인터로 변수y의 주소를 저장하고 있다는 뜻이 됨. 

// *pa = 10; 
// 간접 참조 연산자를 사용하는 문장. 포인터 pa가 a를 가리키므로 *pa에 10을 대입하면 결국 a에 10을 대입하는 것과 같음. 

// 11행에서 *pa를 출력하면 a값이 출력됨. 12행에서 a를 출력한 결과와 같음을 확인할 수 있음. 

// *pa == a // True

// scanf 함수로 입력할 때는 메모리 어디에 할당되었는지 저장공간의 위치를 알아함.
// 그래서 입력할 변수의 주소를 인수로 줌. 
// 포인터 pa를 통해 변수 a에 입력할 때에도 마찬가지. 
//